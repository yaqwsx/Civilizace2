{% extends "base.html" %}

{% block title %}Náhled technologického stromu{% endblock %}

{% block content %}

<script src="/static/js/d3.jmin.s"></script>
<script src="/static/js/dagre-d3.min.js"></script>

<style>
.node rect {
  padding: 0;
  background: none;
  border: none;
  fill: white;
  stroke: black;
}

.edgePath path {
  stroke: #333;
  fill: #333;
  stroke-width: 1.5px;
}
</style>

<h1>Náhled technologického stromu</h1>


<svg id="graph" class="w-full h-screen">
    <g/>
</svg>

<script>
    var g = new dagreD3.graphlib.Graph().setGraph({});

    {% for tech in nodes %}
        var div = document.createElement("div");
        var html = '<div class="text-sm" style="width: 300px; white-space: normal;">';
        html += '<h3 class="text-lg border-b">' + "{{tech.label}}" + '</h3>';
        html += '<p>' + "{{tech.flavour}}" + '</p>';
        {% if tech.unlock_vyrobas.all %}
            html += '<b>Odemyká výroby:</b>'
            html += '<ul class="list-disc">';
            {% for vyroba in tech.unlock_vyrobas.all %}
                html += '<li>' + "{{vyroba.label}}" + '</li>';
            {% endfor %}
            html += '</ul>';
        {% endif %}
        html += '</div>';
        div.innerHTML = html;
        g.setNode( "{{tech.id}}", { label: div });
    {% endfor %}

    {% for edge in edges %}
        g.setEdge( "{{edge.src.id}}", "{{edge.dst.id}}", { label: "{{edge.costText}}" });
    {% endfor %}

    // Automatically label each of the nodes
    // states.forEach(function(state) { g.setNode(state, { label: state }); });

    // Set up the edges
    // g.setEdge("CLOSED",     "LISTEN",     { label: "open" });
    // g.setEdge("LISTEN",     "SYN RCVD",   { label: "rcv SYN" });
    // g.setEdge("LISTEN",     "SYN SENT",   { label: "send" });
    // g.setEdge("LISTEN",     "CLOSED",     { label: "close" });
    // g.setEdge("SYN RCVD",   "FINWAIT-1",  { label: "close" });
    // g.setEdge("SYN RCVD",   "ESTAB",      { label: "rcv ACK of SYN" });
    // g.setEdge("SYN SENT",   "SYN RCVD",   { label: "rcv SYN" });
    // g.setEdge("SYN SENT",   "ESTAB",      { label: "rcv SYN, ACK" });
    // g.setEdge("SYN SENT",   "CLOSED",     { label: "close" });
    // g.setEdge("ESTAB",      "FINWAIT-1",  { label: "close" });
    // g.setEdge("ESTAB",      "CLOSE WAIT", { label: "rcv FIN" });
    // g.setEdge("FINWAIT-1",  "FINWAIT-2",  { label: "rcv ACK of FIN" });
    // g.setEdge("FINWAIT-1",  "CLOSING",    { label: "rcv FIN" });
    // g.setEdge("CLOSE WAIT", "LAST-ACK",   { label: "close" });
    // g.setEdge("FINWAIT-2",  "TIME WAIT",  { label: "rcv FIN" });
    // g.setEdge("CLOSING",    "TIME WAIT",  { label: "rcv ACK of FIN" });
    // g.setEdge("LAST-ACK",   "CLOSED",     { label: "rcv ACK of FIN" });
    // g.setEdge("TIME WAIT",  "CLOSED",     { label: "timeout=2MSL" });

    // Set some general styles
    // g.nodes().forEach(function(v) {
    //     var node = g.node(v);
    //     node.rx = node.ry = 5;
    // });

    // Add some custom colors based on state
    // g.node('CLOSED').style = "fill: #f77";
    // g.node('ESTAB').style = "fill: #7f7";

    var svg = d3.select("#graph");
    var inner = svg.select("g");

    // Set up zoom support
    var zoom = d3.zoom().on("zoom", function() {
        inner.attr("transform", d3.event.transform);
        });
    svg.call(zoom);

    // Create the renderer
    var render = new dagreD3.render();

    // Run the renderer. This is what draws the final graph.
    render(inner, g);

    // Center the graph
    var initialScale = 1;
    svg.call(zoom.transform, d3.zoomIdentity.translate((svg.node().getBBox().width - g.graph().width * initialScale) / 2, 20).scale(initialScale));
</script>

{% endblock %}